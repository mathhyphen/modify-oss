---
name: modify-oss
version: 1.1.0
description: |
  系统化修改开源软件配置或代码的 Skill。
  提供快速/标准/深度三种模式，平衡效率与准确性。
---

# Modify OSS - 开源软件修改助手

## 使用场景

- 修改开源软件的配置文件
- 为开源项目添加新功能
- 修复 bug 或调整行为
- 理解陌生项目的代码结构

## 三种执行模式

根据任务复杂度和紧急程度，选择不同模式：

### 模式 1: 快速模式 ⚡（省 Token）

**适用场景：**
- 软件我之前处理过（查看 memory 有记录）
- 简单配置修改（如改个端口号、开关某个功能）
- 时间紧急，愿意承担一定试错成本

**流程：**
```
1. 检查 memory/TOOLS.md 是否有该软件记录
2. 如果有 → 直接复用之前的方案
3. 如果没有 → 凭经验尝试一次
4. 成功 → 记录到 memory
5. 失败 → 询问是否切换到标准模式
```

**Token 消耗：** ⭐ 低

---

### 模式 2: 标准模式 📋（平衡）

**适用场景：**
- 软件我不熟悉，但任务相对简单
- 需要阅读关键文档，但不需要深入理解架构
- 希望一次成功，但不希望花费太多 Token

**流程：**
```
1. 收集基本信息（软件名、版本、目标）
2. 阅读 README + Configuration 文档（仅关键章节）
3. 制定简化方案（修改清单 + 验证步骤）
4. 执行并验证
5. 记录关键发现
```

**Token 消耗：** ⭐⭐ 中

---

### 模式 3: 深度模式 🔬（完整）

**适用场景：**
- 复杂的企业级软件（如 Kubernetes、OpenStack）
- 关键生产环境配置，不能出错
- 需要深入理解软件架构和工作原理

**流程：**
```
1. Phase 1: 完整信息收集
2. Phase 2: 深入学习（文档 + 源码 + 架构）
3. Phase 3: 详细分析与方案（含风险评估）
4. Phase 4: 小步执行与验证
5. Phase 5: 完整知识沉淀
```

**Token 消耗：** ⭐⭐⭐ 高

---

## 模式选择指南

**用户可以在请求时指定模式：**

| 用户说 | 模式 | 我的行动 |
|--------|------|----------|
| "快速帮我改一下..." / "简单改个..." | 快速模式 | 查 memory → 直接改 |
| "帮我看看这个配置..." / "帮我修改..." | 标准模式 | 读关键文档 → 制定方案 → 执行 |
| "详细帮我分析一下..." / "彻底理解..." | 深度模式 | 完整 5 阶段流程 |

**如果用户没指定，我会根据以下规则自动选择：**

```python
if software in memory or software in TOOLS.md:
    mode = "快速模式"
elif task_complexity == "简单" and not_critical:
    mode = "标准模式"
else:
    mode = "深度模式"  # 默认安全
```

---

## 核心原则（所有模式通用）

1. **先理解，后动手** - 不猜测，只查文档
2. **小步验证** - 每次修改后立即测试
3. **记录知识** - 建立可复用的知识库
4. **回滚准备** - always 保留备份

---

## 标准工作流程（详细版）

### Phase 1: 信息收集 📚

用户发起请求时，需要确认以下信息：

#### 必需信息
```yaml
software:
  name: "软件名称"
  version: "版本号（如果知道）"
  goal: "你想实现什么目标"
  current_state: "当前状态/错误信息"
  urgency: "紧急程度（高/中/低）"
  mode_preference: "模式偏好（快速/标准/深度）"
```

#### 文档和代码位置（按优先级）

| 优先级 | 文档/代码 | 用途 | 快速模式 | 标准模式 | 深度模式 |
|--------|-----------|------|:--------:|:--------:|:--------:|
| P0 | README.md | 项目概览 | ✅ | ✅ | ✅ |
| P0 | 官方配置文档 | 配置项完整参考 | ❌ | ✅ | ✅ |
| P0 | 当前配置文件 | 现有配置结构 | ✅ | ✅ | ✅ |
| P1 | 源码目录结构 | 理解架构 | ❌ | ❌ | ✅ |
| P1 | CHANGELOG.md | 了解版本变更 | ❌ | ❌ | ✅ |
| P2 | 测试用例 | 了解预期行为 | ❌ | ❌ | ✅ |
| P2 | Issues/Discussions | 常见问题和解决方案 | ❌ | ❌ | ✅ |

---

### Phase 2: 学习阶段 🎓

#### 快速模式阅读顺序
```
1. 检查 memory/TOOLS.md
   → 如果有记录 → 直接使用
   → 如果没有 → 看 README

2. README.md（仅概览）
   → 了解项目是什么
   → 找到配置文件位置
   → 直接尝试修改
```

#### 标准模式阅读顺序
```
1. README.md
   → 了解项目是什么、做什么用
   → 找到官方文档链接
   → 记录关键配置文件的默认位置

2. 官方配置文档（仅 Configuration 章节）
   → 配置文件的格式
   → 相关配置项的说明
   → 常见配置示例
```

#### 深度模式阅读顺序
```
1. README.md
2. 官方配置文档（完整阅读）
3. 架构/设计文档（如果有）
4. 当前配置文件（详细分析）
5. 相关源码（关键模块）
```

---

### Phase 3: 分析与方案 🔍

#### 快速模式
```markdown
方案：凭经验尝试
验证：直接测试
回滚：恢复原配置
```

#### 标准模式
```markdown
方案：基于文档制定
- 修改清单（关键配置项）
- 验证步骤
- 回滚计划（简要）
```

#### 深度模式
```markdown
方案：完整方案文档
- 差距分析
- 详细修改清单
- 完整验证步骤
- 风险评估
- 详细回滚计划
- 测试用例
```

---

### Phase 4: 执行与验证 ✅

#### 执行原则（所有模式通用）

```markdown
1. 一次只改一个配置项
2. 每次修改后立即验证
3. 如果验证失败，立即回滚，不要继续
4. 记录每次修改的结果（成功/失败/原因）
```

#### 验证清单

**快速模式：**
- [ ] 修改后功能正常

**标准模式：**
- [ ] 配置文件语法正确
- [ ] 软件能正常启动/重载
- [ ] 目标功能已生效

**深度模式：**
- [ ] 配置文件语法正确
- [ ] 软件能正常启动/重载
- [ ] 日志无 ERROR 或 WARN
- [ ] 目标功能已生效
- [ ] 无副作用（其他功能正常）
- [ ] 性能无下降
- [ ] 安全策略符合预期

---

### Phase 5: 知识沉淀 📝

#### 快速模式
```markdown
# [软件名] - 快速记录
- 修改内容：[简述]
- 解决方案：[关键命令/配置]
- 下次可直接复用
```

#### 标准模式
```markdown
# [软件名] - 配置经验
## 关键发现
- 配置文件位置: [path]
- 重要配置项: [key points]

## 本次修改
- 目标: [goal]
- 修改内容: [changes]
- 验证方法: [verification]
```

#### 深度模式
```markdown
# [软件名] - 完整知识库
## 软件信息
## 架构理解
## 配置详解
## 踩坑记录
## 速查命令
## 最佳实践
```

---

## 常见陷阱与解决方案

### 陷阱 1: 配置优先级混乱
**现象**: 改了 A 文件，但软件读取的是 B 文件
**解决**: 
1. 查看文档中的 "Configuration precedence" 章节
2. 使用 debug 命令查看实际生效的配置
3. 删除或重命名低优先级的配置文件

### 陷阱 2: 配置格式错误
**现象**: 软件拒绝启动，报错 "invalid config"
**解决**:
1. 使用 schema 验证工具
2. 对比官方示例配置
3. 逐步注释掉新增配置，定位错误

### 陷阱 3: 配置项名称猜错
**现象**: 配置了 X，但软件似乎没读取
**解决**:
1. 查官方文档，确认正确的 key 名
2. 检查大小写（camelCase vs snake_case）
3. 检查层级（`.key` vs `.section.key`）

### 陷阱 4: 需要重启才能生效
**现象**: 改了配置，但行为没变
**解决**:
1. 查看文档中的 "Reloading configuration" 章节
2. 尝试 reload 命令
3. 如果必须重启，确保有备份

### 陷阱 5: 环境变量覆盖
**现象**: 配置文件改了，但实际值还是旧的
**解决**:
1. 检查环境变量
2. 查看文档中的 "Environment variables" 章节
3. 临时 unset 环境变量测试

---

## 工具与资源

### 配置验证工具
- **JSON**: `jq`, `jsonlint`
- **YAML**: `yamllint`, `python -c 'import yaml; yaml.safe_load(open("file.yaml"))'`
- **TOML**: `toml-cli`

### 调试技巧
```bash
# 查看软件实际读取的配置
strace -e open,openat software 2>&1 | grep config

# 测试配置（干跑模式）
software --dry-run --config-file=new-config.yaml
```

---

## 使用示例

### 场景 1: 快速修改已知软件

```
用户: 快速帮我改一下 OpenClaw，让 Python 免批准执行

助手: 
1. 检查 memory → 发现已有记录
2. 复用之前的方案（删除 tools.exec 配置）
3. 重启验证
4. 记录成功

Token 消耗: 低 ✅
```

### 场景 2: 标准模式修改新软件

```
用户: 帮我看看 Nginx，想加一个反向代理

助手:
1. 询问基本信息
2. 阅读 Nginx README + Configuration
3. 制定方案（upstream + server + location）
4. 执行并验证
5. 记录关键配置

Token 消耗: 中 📊
```

### 场景 3: 深度模式理解复杂软件

```
用户: 详细帮我理解 Kubernetes 的调度器配置

助手:
1. 完整信息收集
2. 阅读 K8s 文档、源码、架构设计
3. 详细分析调度器工作原理
4. 制定完整的调优方案
5. 小步实施，每步验证
6. 建立完整知识库

Token 消耗: 高 🔬
```

---

## 检查清单（Checklist）

### 修改前

- [ ] 已明确用户想要的模式（快速/标准/深度）
- [ ] 已检查 memory/TOOLS.md 是否有该软件记录
- [ ] 已阅读相应级别的文档
- [ ] 已备份原配置
- [ ] 已明确知道修改后如何验证

### 修改后

- [ ] 已验证配置语法正确
- [ ] 已验证服务正常启动
- [ ] 已验证目标功能生效
- [ ] 已记录到 memory/TOOLS.md

---

## 总结

**黄金法则:**

1. **永远不要猜测配置项名称** - 只查官方文档
2. **永远不要一次改多个配置** - 小步迭代
3. **永远不要跳过验证** - 每步都要确认
4. **永远保留备份** - 方便回滚
5. **永远记录经验** - 避免重复踩坑

**执行口诀:**

```
读文档 → 理配置 → 小步改 → 立即验 → 记经验
```

**Token 优化口诀:**

```
熟悉的用快速，陌生的用标准，复杂的用深度
一次记录，终身复用
```
